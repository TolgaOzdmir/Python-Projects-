// Scale in the key of 25000 
// Automatically generated by scaleGenerator.py 

#define  C0    25000
#define  Cx0   23597
#define  D0    22272
#define  Dx0   21022
#define  E0    19843
#define  F0    18729
#define  Fx0   17678
#define  G0    16685
#define  Gx0   15749
#define  A0    14865
#define  Ax0   14031
#define  B0    13243
#define  C1    12500
#define  Cx1   11798
#define  D1    11136
#define  Dx1   10511
#define  E1     9921
#define  F1     9364
#define  Fx1    8839
#define  G1     8343
#define  Gx1    7875
#define  A1     7433
#define  Ax1    7015
#define  B1     6622
#define  C2     6250
#define  Cx2    5899
#define  D2     5568
#define  Dx2    5256
#define  E2     4961
#define  F2     4682
#define  Fx2    4419
#define  G2     4171
#define  Gx2    3937
#define  A2     3716
#define  Ax2    3508
#define  B2     3311
#define  C3     3125
#define  Cx3    2950
#define  D3     2784
#define  Dx3    2628
#define  E3     2480
#define  F3     2341
#define  Fx3    2210
#define  G3     2086
#define  Gx3    1969
#define  A3     1858
#define  Ax3    1754
#define  B3     1655
#define  C4     1562
#define  Cx4    1475
#define  D4     1392
#define  Dx4    1314
#define  E4     1240
#define  F4     1171
#define  Fx4    1105
#define  G4     1043
#define  Gx4     984
#define  A4      929
#define  Ax4     877
#define  B4      828
#define  C5      781
#define  Cx5     737
#define  D5      696
#define  Dx5     657
#define  E5      620
#define  F5      585
#define  Fx5     552
#define  G5      521
#define  Gx5     492
#define  A5      465
#define  Ax5     438
#define  B5      414
#define  C6      391
#define  Cx6     369
#define  D6      348
#define  Dx6     328
#define  E6      310
#define  F6      293
#define  Fx6     276
#define  G6      261
#define  Gx6     246
#define  A6      232
#define  Ax6     219
#define  B6      207
#define  C7      195
#define  Cx7     184
#define  D7      174
#define  Dx7     164
#define  E7      155
#define  F7      146
#define  Fx7     138
#define  G7      130
#define  Gx7     123
#define  A7      116
#define  Ax7     110
#define  B7      103


// ------------- Function prototypes -------------- //

// Plays a note for the given duration.  None of these times are
//  calibrated to actual notes or tempi.  It's all relative to TIMEBASE.
void playNote(uint16_t period, uint16_t duration);

// Does nothing for a time equal to the passed duration.
void rest(uint16_t duration);

/*
Simple routines to play notes out to a speaker
*/

// ---------------
//   Pin Defines
// ---------------

#define LED_PORT                PORTB
#define LED_PIN                 PINB
#define LED_DDR                 DDRB

#define LED0                    PB0
#define LED1                    PB1
#define LED2                    PB2
#define LED3                    PB3
#define LED4                    PB4
#define LED5                    PB5
#define LED6                    PB6
#define LED7                    PB7

#define BUTTON_PORT             PORTD
#define BUTTON_PIN              PIND
#define BUTTON_DDR              DDRD

#define BUTTON                  PD2
#define BUTTON2                 PD3
#define BUTTON3                 PD4

#define SPEAKER                 PD6                            /* OC0A */
#define SPEAKER_PORT            PORTD
#define SPEAKER_PIN             PIND
#define SPEAKER_DDR             DDRD

#define ANTENNA                 PD5                            /* OC0B */
#define ANTENNA_PORT            PORTD
#define ANTENNA_PIN             PIND
#define ANTENNA_DDR             DDRD

#define MODULATION              PD3                            /* OC2B */
#define MODULATION_PORT         PORTD
#define MODULATION_PIN          PIND
#define MODULATION_DDR          DDRD

#define LIGHT_SENSOR            PC0                            /* ADC0 */
#define LIGHT_SENSOR_PORT       PORTC
#define LIGHT_SENSOR_PIN        PINC
#define LIGHT_SENSOR_DDR        DDRC

#define CAP_SENSOR              PC1                            /* ADC1 */
#define CAP_SENSOR_PORT         PORTC
#define CAP_SENSOR_PIN          PINC
#define CAP_SENSOR_DDR          DDRC

#define PIEZO                   PC2                            /* ADC2 */
#define PIEZO_PORT              PORTC
#define PIEZO_PIN               PINC
#define PIEZO_DDR               DDRC

#define POT                     PC3                            /* ADC3 */
#define POT_PORT                PORTC
#define POT_PIN                 PINC
#define POT_DDR                 DDRC

//  SPI and I2C serial mode defines

#define SPI_SS                     PB2
#define SPI_SS_PORT                PORTB
#define SPI_SS_PIN                 PINB
#define SPI_SS_DDR                 DDRB

#define SPI_MOSI                     PB3
#define SPI_MOSI_PORT                PORTB
#define SPI_MOSI_PIN                 PINB
#define SPI_MOSI_DDR                 DDRB

#define SPI_MISO                     PB4
#define SPI_MISO_PORT                PORTB
#define SPI_MISO_PIN                 PINB
#define SPI_MISO_DDR                 DDRB

#define SPI_SCK                     PB5
#define SPI_SCK_PORT                PORTB
#define SPI_SCK_PIN                 PINB
#define SPI_SCK_DDR                 DDRB

#define I2C_SDA                     PC4
#define I2C_SDA_PORT                PORTC
#define I2C_SDA_PIN                 PINC
#define I2C_SDA_DDR                 DDRC

#define I2C_SCL                     PC5
#define I2C_SCL_PORT                PORTC
#define I2C_SCL_PIN                 PINC
#define I2C_SCL_DDR                 DDRC

#include <avr/io.h>
#include <util/delay.h>



#ifndef BAUD                          /* if not defined in Makefile... */
#define BAUD  9600                     /* set a safe default baud rate */
#endif

                                  /* These are defined for convenience */
#define   USART_HAS_DATA   bit_is_set(UCSR0A, RXC0)
#define   USART_READY      bit_is_set(UCSR0A, UDRE0)


void initUSART(void);

/* Blocking transmit and receive functions.
   When you call receiveByte() your program will hang until
   data comes through.  We'll improve on this later. */
void transmitByte(uint8_t data);
uint8_t receiveByte(void);

void printString(const char myString[]);
             /* Utility function to transmit an entire string from RAM */
void readString(char myString[], uint8_t maxLength);
/* Define a string variable, pass it to this function
   The string will contain whatever you typed over serial */

void printByte(uint8_t byte);
                  /* Prints a byte out as its 3-digit ascii equivalent */
void printWord(uint16_t word);
        /* Prints a word (16-bits) out as its 5-digit ascii equivalent */

void printBinaryByte(uint8_t byte);
                                     /* Prints a byte out in 1s and 0s */
char nibbleToHex(uint8_t nibble);
char nibbleToHexCharacter(uint8_t nibble);
void printHexByte(uint8_t byte);
                                   /* Prints a byte out in hexadecimal */
uint8_t getNumber(void);
/* takes in up to three ascii digits,
 converts them to a byte when press enter */


//#include <avr/io.h>
//#include <util/setbaud.h>

void initUSART(void) {                                /* requires BAUD */
  UBRR0H = UBRRH_VALUE;                        /* defined in setbaud.h */
  UBRR0L = UBRRL_VALUE;
#if USE_2X
  UCSR0A |= (1 << U2X0);
#else
  UCSR0A &= ~(1 << U2X0);
#endif
                                  /* Enable USART transmitter/receiver */
  UCSR0B = (1 << TXEN0) | (1 << RXEN0);
  UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);   /* 8 data bits, 1 stop bit */
}


void transmitByte(uint8_t data) {
                                     /* Wait for empty transmit buffer */
  loop_until_bit_is_set(UCSR0A, UDRE0);
  UDR0 = data;                                            /* send data */
}

uint8_t receiveByte(void) {
  loop_until_bit_is_set(UCSR0A, RXC0);       /* Wait for incoming data */
  return UDR0;                                /* return register value */
}


                       /* Here are a bunch of useful printing commands */

void printString(const char myString[]) {
  uint8_t i = 0;
  while (myString[i]) {
    transmitByte(myString[i]);
    i++;
  }
}

void readString(char myString[], uint8_t maxLength) {
  char response;
  uint8_t i;
  i = 0;
  while (i < (maxLength - 1)) {                   /* prevent over-runs */
    response = receiveByte();
    transmitByte(response);                                    /* echo */
    if (response == '\r') {                     /* enter marks the end */
      break;
    }
    else {
      myString[i] = response;                       /* add in a letter */
      i++;
    }
  }
  myString[i] = 0;                          /* terminal NULL character */
}

void printByte(uint8_t byte) {
              /* Converts a byte to a string of decimal text, sends it */
  transmitByte('0' + (byte / 100));                        /* Hundreds */
  transmitByte('0' + ((byte / 10) % 10));                      /* Tens */
  transmitByte('0' + (byte % 10));                             /* Ones */
}

void printWord(uint16_t word) {
  transmitByte('0' + (word / 10000));                 /* Ten-thousands */
  transmitByte('0' + ((word / 1000) % 10));               /* Thousands */
  transmitByte('0' + ((word / 100) % 10));                 /* Hundreds */
  transmitByte('0' + ((word / 10) % 10));                      /* Tens */
  transmitByte('0' + (word % 10));                             /* Ones */
}

void printBinaryByte(uint8_t byte) {
                       /* Prints out a byte as a series of 1's and 0's */
  uint8_t bit;
  for (bit = 7; bit < 255; bit--) {
    if (bit_is_set(byte, bit))
      transmitByte('1');
    else
      transmitByte('0');
  }
}

char nibbleToHexCharacter(uint8_t nibble) {
                                   /* Converts 4 bits into hexadecimal */
  if (nibble < 10) {
    return ('0' + nibble);
  }
  else {
    return ('A' + nibble - 10);
  }
}

void printHexByte(uint8_t byte) {
                        /* Prints a byte as its hexadecimal equivalent */
  uint8_t nibble;
  nibble = (byte & 0b11110000) >> 4;
  transmitByte(nibbleToHexCharacter(nibble));
  nibble = byte & 0b00001111;
  transmitByte(nibbleToHexCharacter(nibble));
}

uint8_t getNumber(void) {
  // Gets a numerical 0-255 from the serial port.
  // Converts from string to number.
  char hundreds = '0';
  char tens = '0';
  char ones = '0';
  char thisChar = '0';
  do {                                                   /* shift over */
    hundreds = tens;
    tens = ones;
    ones = thisChar;
    thisChar = receiveByte();                   /* get a new character */
    transmitByte(thisChar);                                    /* echo */
  } while (thisChar != '\r');                     /* until type return */
  return (100 * (hundreds - '0') + 10 * (tens - '0') + ones - '0');
}



#define BUTTON_DDR DDRD
#define BUTTON_PORT PORTD
#define PB_PD4 PD4
#define PB_PD3 PD3
#define SPEAKER_PORT PORTD
#define BUTTON_PIN PIND
#define LED PB0
#define LED_DDR DDRB
#define LED_PORT PORTB

void playNote(uint16_t period, uint16_t duration) {
  uint16_t elapsed;
  uint16_t i;
  for (elapsed = 0; elapsed < duration; elapsed += period) {
                     /* For loop with variable delay selects the pitch */
    for (i = 0; i < period; i++) {
      _delay_us(1);
    }
    SPEAKER_PORT ^= (1 << SPEAKER);
  }
}

void rest(uint16_t duration) {
  do {
    _delay_us(1);
  } while (--duration);
}


int main(void) {
  BUTTON_DDR  &= ~(1 << PB_PD4)|~(1 << PB_PD3);				/* Button for input */
  BUTTON_PORT |= (1 << PB_PD4)|(1 << PB_PD3);                    /* pullup on button */
  LED_DDR |= (1 << LED);
  uint8_t wasButtonPressed = 0;
  initUSART();

  // ------ Event loop ------ //
  while (1) {
    if (bit_is_clear(BUTTON_PIN, PB_PD4)) {
      if (!wasButtonPressed) {              /* if it's a new press ... */
      
        wasButtonPressed = 1;
        char command[100];
        strcpy( command, "python main.py 4");
        system(command);
        //printString("S");
        LED_PORT |= (1 << LED); /*Turn on LED*/
        _delay_ms(1000);
        LED_PORT &= ~(1 << LED); /*Turn off LED*/
      }
    }
    else if(bit_is_clear(BUTTON_PIN, PB_PD3)){
      if (!wasButtonPressed) {
        wasButtonPressed = 1;
        char command[100];
        strcpy( command, "python main.py 3");
        system(command);
        //printString("X");
        LED_PORT |= (1 << LED); /*Turn on LED*/
        _delay_ms(1000);
        LED_PORT &= ~(1 << LED); /*Turn off LED*/
      }
    }
    else {
      wasButtonPressed = 0;
    }
  }                                                  /* End event loop */
  return 0;
}
